---
title: "Making a data frame from a list from GitHub API"
---

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

One of the best uses for `purrr`'s `map()` functions is for digging information out of a nested list and creating a neat data frame. Where do these lists come from? Often as JSON or XML from an API.

Here we'll explore some lists that come from calling the [GitHub API](https://developer.github.com/v3/).

```{r}
library(purrr)
suppressMessages(library(jsonlite))
library(listviewer)
library(tibble)
suppressMessages(library(dplyr))
```

### Get a GitHub user

Retrieve information on a single GitHub user. Feel free to substitute your own username.

*If you don't want to call the GitHub API, the raw JSON is available.*

```{r include = FALSE, eval = FALSE}
gabor_response <- httr::GET("https://api.github.com/users/gaborcsardi")
gabor_json <- httr::content(gabor_response, as = "text")
writeLines(gabor_json, "gabor.json")

unames <-
  c("gaborcsardi", "jennybc", "masalmon", "juliasilge", "leeper", "jtleek")
urls <- paste0("https://api.github.com/users/", unames)
users <- urls %>% map(fromJSON)
writeLines(toJSON(users), "github_users.json")
```

Download this if you prefer:  
<https://github.com/jennybc/purrr-tutorial/raw/gh-pages/gabor.json>

```{r}
## pick one:
#gabor <- fromJSON("gabor.json")
gabor <- fromJSON("https://api.github.com/users/gaborcsardi")
str(gabor, give.attr = FALSE)
```

Info for one user = a list.

### Get several GitHub users

What if we want information on several GitHub users? The `jsonlite::fromJSON()` function is not vectorized but we can use `map()` to iteratively make calls for several users. This will yield a list of lists, *a nested list*.

Download this if you prefer:  
<https://github.com/jennybc/purrr-tutorial/raw/gh-pages/github_users.json>

```{r}
unames <-
  c("gaborcsardi", "jennybc", "masalmon", "juliasilge", "leeper", "jtleek")

## pick one
# urls <- paste0("https://api.github.com/users/", unames)
# users <- map(urls, fromJSON)
users <- fromJSON("github_users.json", simplifyDataFrame = FALSE)

jsonedit(setNames(users, unames))
```

<!--
To have the interactive list viewing experience, visit <http://rpubs.com/jennybc/github-users>.
-->

### Shortcuts to extract elements by name or position

Reach into each user's list and pull elements out.

Shortcut for making the `.f` function that `map()` will apply:

  * provide "TEXT" to extract the element named "TEXT"
  * equivalent to `function(x) x[["TEXT"]]`

```{r}
users %>% 
  map_chr("name")

## equivalent to the more verbose
users %>%
  map_chr(function(x) x[["name"]])
```

Or extract by position:

  * provide `i` to extract the `i`-th element
  * equivalent to `function(x) x[[i]]`

```{r}
users %>% 
  map_chr(1)

## equivalent to the more verbose
users %>%
  map_chr(function(x) x[[1]])
```

### Multiple values at same level of hierarchy

A trick for retrieving multiple values at the same level of the hierarchy is to map the function `[` and provide a character or integer vector as an additional argument.

```{r}
x <- users %>%
  map(`[`, c("login", "name", "id", "location"))
str(x[[1]])

## if you find this ugly, try magrittr::extract()
x <- users %>%
  map(magrittr::extract, c("login", "name", "id", "location"))

y <- users %>% 
  map(`[`, 1:2)
str(y[[2]])
```

What's really awesome is to stack up these per-users lists row-wise and make a data frame. We use the special mapping function `map_df()` to signal that we want a data frame back.

```{r}
users %>%
  map_df(`[`, c("login", "name", "id", "location"))
```

Another, more cumbersome but safer way to get this same data frame is to form variables explicitly like so:

```{r}
users %>% {
  tibble(
    login = map_chr(., "login"),
    name = map_chr(., "name"),
    id = map_int(., "id"),
    location = map_chr(., "location")
  )
}
```

### Get repos by user

You can index at deeper levels with a character or integer vector, but our current example doesn't support this.
 
*under development*

```{r}
library(tibble)
# repos <- unames %>% 
#   map(~ gh("/users/:user/repos", user = .x, .limit = Inf))
# saveRDS(repos, "github_repos.rds")
repos <- readRDS("github_repos.rds")
(rdf <- repos %>%
    set_names(unames) %>% 
    enframe(value = "gh_repos"))
jsonedit(set_names(repos, unames))
```

Download this:  
<https://github.com/jennybc/purrr-tutorial/raw/gh-pages/github_repos.rds>

Make user-specific data frames, one row per repo. Then `unnest()` the enclosing data frame to get one row per repo.

```{r}
rdf %>% 
  mutate(
    #n_repos = map_int(gh_repos, length),
    repo_info = gh_repos %>%
      map(. %>% map_df(`[`, c("name", "fork", "open_issues")))
  ) %>% 
  select(-gh_repos) %>% 
  tidyr::unnest()
```

