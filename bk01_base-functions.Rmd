---
title: "Relationship to base and plyr functions"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

```{r}
library(tidyverse)
library(repurrrsive)
```

## Why not base?

You need a way to iterate in R in a data-structure-informed way. What does that mean?

  * Iterate over elements of a list
  * Iterate over sub data frames induced by one or more factors
  * Iterate over rows or columns of a 2-dimensional object
  * Iterate over tuples formed from the i-th element of several vectors of equal-length

All of this is absolutely possible with base R, using `for()` loops or the "apply" functions, such as `apply()`, `[slvmt]apply()`, `split()`, and `by()`. I know, because I did so religiously for over 15 years.

What's the problem? As an instructor, I encounter lots of useRs who sheepishly say they know they should be using the apply functions, but they don't. Because they've never quite figured them out or been able to form the habit.

I have a theory about why. The apply functions are not particularly easy or convenient to use. The user interface is not as consistent as it could be, which slows down learning. The return objects frequently require further checking and massage to use downstream, which diminishes the payoff.

## Why purrr?

purrr addresses some of the friction identified in the base functions for "split-apply-combine":

  * The `map()` family of functions is highly internally consistent, making it easier to transfer expertise from one function to another.
  * Greater encouragement for type-safe simplification, i.e. conversion from list to atomic vector or data frame.
  * Concise syntax for defining anonymous functions.
  
## Why not plyr?

If you have never heard of the [plyr package](https://CRAN.R-project.org/package=plyr), you can skip this section! Personally, I'm a bit sad that it's time to move on from plyr. But it probably is.

Why? It's no longer under active development. The innovation is happening elsewhere, in purrr and the other packages in the tidyverse. Also, even I must admit that plyr can be rather slow. I wouldn't recommend writing new code that requires plyr.

In terms of understanding or translating plyr code, here's the minimum you need to know: The key feature of the main 3 * 4 = 12 functions in plyr is their explicit, memorable form.

```{r eval = FALSE}
XYply()
```

where `X` and `Y` specify the type of input and output respectively. `X` and `Y` take values from here:

  * `a` = "array"
  * `d` = "data frame"
  * `l` = "list"
  * `_` = "nothing" (not eligible as `X` re: input, for obvious reasons)
  
The most useful function proved to be `ddply()`: data frame in, data frame out. This is now handled by dplyr and tidyr. Most tasks suitable for `a*ply()` and, especially `l*ply()` are now handled by purrr's `map()` family. The functions called for their side effects, as opposed to return value, are those named `*_ply()`; this is handled by purrr's `walk()` functions. Marching through a data frame row by row is now a job for purrr's `pmap()`.

## `lapply()` and `purrr::map()`

The main (only?) difference is access to purrr's shortcuts for anonymous functions.

<div class = "row">
<div class = "col-md-6">
```{r}
lapply(got_chars[1:3],
       function(x) x[["name"]])
```
</div>
<div class = "col-md-6">
```{r}
map(got_chars[1:3], "name")
```
</div>
</div>

This is also `plyr::llply()`, although it offers some other arguments, such as `.progress` and `.parallel`.

```{r eval = FALSE}
plyr::llply(got_chars[1:3], function(x) x[["name"]])
```

## `sapply()` and ???

`sapply()` is a base function that attempts to apply a reasonable simplification to the output of `lapply()`. It's fine for interactive use, but due to the unpredictability of it return value, it's unwise to use it in programming. There is no equivalent in purrr or plyr.

Problem demonstration: The characters in Game of Thrones can have aliases. Some have several, some have one, some have none. Depending on which characters I work with, the same code can return an object of entirely different class, i.e. a list or a character vector:

```{r}
(aliases1 <- sapply(got_chars[2:4], function(x) x[["aliases"]]))
str(aliases1)
(aliases2 <- sapply(got_chars[c(14, 22, 25)], function(x) x[["aliases"]]))
str(aliases2)
```

## `vapply()` and `map_*()`

`vapply()`, some similarities with `map_chr()`, `map_lgl()`, etc. Touted as the base option for programming, but still unpredictable.

<div class = "row">
<div class = "col-md-6">
```{r}
vapply(got_chars[1:3],
       function(x) x[["name"]], character(1))
```
</div>
<div class = "col-md-6">
```{r}
map_chr(got_chars[1:3], "name")
```
</div>
</div>

Example gotcha from real life. Using `vapply()` inside a function. `n` can vary depending on input. But `vapply()`'s simplifying behavior means it will return 2D or 1D object, depending on `n`. It has no way to say `drop = FALSE`.

<div class = "row">
<div class = "col-md-6">
```{r}
f <- function(x, n) rep(x, n)
n <- 3
vapply(c("a", "b"), f, character(n), n = n)
n <- 1
vapply(c("a", "b"), f, character(n), n = n)
```
</div>
<div class = "col-md-6">
```{r}
f <- function(x, n) rep(x, n)
map(c("a", "b"), f, n = 3) %>% lift_dl(cbind)(.)
map(c("a", "b"), f, n = 1) %>% lift_dl(cbind)(.)
```
</div>
</div>

## `mapply()` and `map2()`, `pmap()`

## `tapply()`, `aggregate()`
